<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Live2D Full Body Tracker</title>
    <script src="https://cdn.jsdelivr.net/npm/pixi.js@7.x/dist/pixi.min.js"></script>
    <script src="https://cubism.live2d.com/sdk-web/bin/cubismcore/live2dcubismcore.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pixi-live2d-display/dist/index.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/holistic/holistic.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; background-color: #fce4ec; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #canvas-container { position: relative; width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; }
        #video-container { position: absolute; bottom: 20px; right: 20px; width: 240px; height: 180px; border-radius: 15px; overflow: hidden; border: 4px solid #f06292; box-shadow: 0 10px 20px rgba(0,0,0,0.2); z-index: 10; transition: all 0.3s; }
        #video-container.fullscreen { width: 100vw; height: 100vh; bottom: 0; right: 0; border: none; border-radius: 0; }
        video, canvas.overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; }
        .controls { position: absolute; top: 20px; left: 20px; z-index: 20; display: flex; gap: 10px; }
        .btn { background: #f06292; color: white; padding: 10px 20px; border-radius: 25px; cursor: pointer; border: none; font-weight: bold; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
        .btn:hover { background: #ec407a; transform: scale(1.05); }
        .status { position: absolute; bottom: 20px; left: 20px; color: #ad1457; background: rgba(255,255,255,0.7); padding: 5px 15px; border-radius: 20px; font-size: 14px; }
        #loading-screen { position: fixed; inset: 0; background: #fce4ec; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 100; }
        .heart { color: #f06292; font-size: 50px; animation: pulse 1s infinite; }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.2); } 100% { transform: scale(1); } }
    </style>
</head>
<body>

    <div id="loading-screen">
        <div class="heart">♥</div>
        <div class="mt-4 text-pink-600 font-bold">กำลังโหลดโมเดลจิบิสุดน่ารัก...</div>
    </div>

    <div class="controls">
        <button class="btn" onclick="toggleView('avatar')">โหมดโมเดล (Avatar)</button>
        <button class="btn" onclick="toggleView('camera')">โหมดตรวจจับ (Skeleton)</button>
    </div>

    <div id="canvas-container">
        <!-- PixiJS จะเรนเดอร์โมเดลที่นี่ -->
    </div>

    <div id="video-container" id="v-container">
        <video id="input-video" playsinline></video>
        <canvas id="output-canvas" class="overlay"></canvas>
    </div>

    <div class="status" id="status-text">ระบบพร้อมทำงาน: กรุณาอนุญาตเข้าถึงกล้อง</div>

    <script>
        const videoElement = document.getElementById('input-video');
        const canvasElement = document.getElementById('output-canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const statusText = document.getElementById('status-text');
        
        let currentMode = 'avatar';
        let model;
        let app;

        // ฟังก์ชันสลับหน้าจอ
        function toggleView(mode) {
            currentMode = mode;
            const vContainer = document.getElementById('video-container');
            if (mode === 'camera') {
                vContainer.classList.add('fullscreen');
                statusText.innerText = "โหมด: ตรวจจับโครงสร้างร่างกาย (Skeleton Mode)";
            } else {
                vContainer.classList.remove('fullscreen');
                statusText.innerText = "โหมด: Avatar (ขยับตามร่างกาย)";
            }
        }

        async function initPixi() {
            app = new PIXI.Application({
                view: document.createElement('canvas'),
                width: window.innerWidth,
                height: window.innerHeight,
                transparent: true,
                antialias: true,
                autoStart: true
            });
            document.getElementById('canvas-container').appendChild(app.view);

            // ตัวอย่างโมเดลคุณภาพสูง (ใช้ Sample Model จาก Live2D SDK)
            // หมายเหตุ: ในการใช้งานจริง คุณสามารถเปลี่ยน URL เป็นไฟล์ .model3.json ของคุณได้
            const modelUrl = 'https://cdn.jsdelivr.net/gh/guansss/pixi-live2d-display/test/assets/shizuku/shizuku.model.json';
            
            try {
                model = await PIXI.live2d.Live2DModel.from(modelUrl);
                app.stage.addChild(model);
                
                // ตั้งค่าขนาดและตำแหน่งโมเดล
                const scale = Math.min(app.screen.width / model.width, app.screen.height / model.height) * 0.8;
                model.scale.set(scale);
                model.anchor.set(0.5, 0.5);
                model.x = app.screen.width / 2;
                model.y = app.screen.height / 2;

                document.getElementById('loading-screen').style.display = 'none';
                statusText.innerText = "โหลดโมเดลสำเร็จ! เริ่มตรวจจับใบหน้าและร่างกาย...";
            } catch (e) {
                console.error(e);
                statusText.innerText = "เกิดข้อผิดพลาดในการโหลดโมเดล";
            }
        }

        function onResults(results) {
            // ล้าง Canvas สำหรับวาด Skeleton
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            
            // วาดภาพจากกล้อง (เฉพาะโหมด Camera)
            if (currentMode === 'camera') {
                canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
                drawConnectors(canvasCtx, results.poseLandmarks, HOLISTIC_CONNECTIONS, {color: '#00FF00', lineWidth: 4});
                drawLandmarks(canvasCtx, results.poseLandmarks, {color: '#FF0000', lineWidth: 2});
                drawConnectors(canvasCtx, results.faceLandmarks, FACEMESH_TESSELATION, {color: '#C0C0C070', lineWidth: 1});
                drawConnectors(canvasCtx, results.leftHandLandmarks, HAND_CONNECTIONS, {color: '#CC0000', lineWidth: 5});
                drawConnectors(canvasCtx, results.rightHandLandmarks, HAND_CONNECTIONS, {color: '#00CC00', lineWidth: 5});
            }

            // แมปค่าจาก Tracking ไปยังโมเดล Live2D
            if (model && results.faceLandmarks) {
                // ตัวอย่างการคุมการมอง (Eye/Head Movement)
                const nose = results.faceLandmarks[1]; // จุดจมูก
                const leftEye = results.faceLandmarks[33];
                const rightEye = results.faceLandmarks[263];

                // คำนวณการหมุนหัว (Yaw, Pitch)
                const headX = (nose.x - 0.5) * 2; // -1 to 1
                const headY = (nose.y - 0.5) * -2; // -1 to 1

                model.internalModel.coreModel.setParameterValueById('ParamAngleX', headX * 30);
                model.internalModel.coreModel.setParameterValueById('ParamAngleY', headY * 30);
                
                // ตรวจสอบการกะพริบตา (ใช้ระยะห่างเปลือกตา)
                const eyeOpenL = Math.abs(results.faceLandmarks[159].y - results.faceLandmarks[145].y) > 0.015 ? 1 : 0;
                const eyeOpenR = Math.abs(results.faceLandmarks[386].y - results.faceLandmarks[374].y) > 0.015 ? 1 : 0;
                
                model.internalModel.coreModel.setParameterValueById('ParamEyeLOpen', eyeOpenL);
                model.internalModel.coreModel.setParameterValueById('ParamEyeROpen', eyeOpenR);

                // การขยับปาก (Mouth Open)
                const mouthDist = Math.abs(results.faceLandmarks[13].y - results.faceLandmarks[14].y);
                const mouthOpen = Math.min(mouthDist * 10, 1);
                model.internalModel.coreModel.setParameterValueById('ParamMouthOpenY', mouthOpen);

                // การขยับไหล่และตัว
                if (results.poseLandmarks) {
                    const shoulderL = results.poseLandmarks[11];
                    const shoulderR = results.poseLandmarks[12];
                    const bodyTilt = (shoulderL.y - shoulderR.y) * 50;
                    model.internalModel.coreModel.setParameterValueById('ParamBodyAngleZ', bodyTilt);
                }
            }
            canvasCtx.restore();
        }

        // ตั้งค่า Holistic Tracking
        const holistic = new Holistic({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/holistic/${file}`;
        }});

        holistic.setOptions({
            modelComplexity: 1,
            smoothLandmarks: true,
            enableSegmentation: false,
            refineFaceLandmarks: true,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        holistic.onResults(onResults);

        const camera = new Camera(videoElement, {
            onFrame: async () => {
                await holistic.send({image: videoElement});
            },
            width: 640,
            height: 480
        });

        // เริ่มต้นทำงานทั้งหมด
        window.onload = () => {
            initPixi();
            camera.start();
            
            // ปรับขนาดแคนวาสเมื่อเปลี่ยนขนาดจอ
            window.onresize = () => {
                if(app) {
                    app.renderer.resize(window.innerWidth, window.innerHeight);
                    if(model) {
                        model.x = app.screen.width / 2;
                        model.y = app.screen.height / 2;
                    }
                }
            };
        };
    </script>
</body>
</html>

